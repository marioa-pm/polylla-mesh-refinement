// https://jerryyin.info/geometry-processing-algorithms/half-edge/
// https://doc.cgal.org/latest/Arrangement_on_surface_2/classCGAL_1_1Arrangement__2_1_1Halfedge.html
// https://threejs.org/docs/#examples/en/math/convexhull/HalfEdge.vertex


// half-edge triangulation
/*
Basic operations
    incident_face(e): return the face incident to e
    twin(e): return the twin halfedge of e
    next(e): return the next halfedge of e
    prev(e): return the previous halfedge of e
    origin(e): return the first vertex of halfedge e
    target(e): return the second vertex of halfedge e
Others
    CCW_edge_to_vertex(e): return the next CCW edge incident to v after e
    edge_of_vertex(v): return A edge incident to v
    is_border_face(e): return true if the incent face of e is a border face
    is_interior(e): return true if the incent face of e is an interior face
    is_border_vertex(e): return true if the vertex v is part of the boundary
    faces(): return number of faces
    halfEdges(): Return number of halfedges
    vertices(): Return number of vertices
    get_Triangles(): bitvector of triangles where true if the halfege generate a unique face, false if the face is generated by another halfedge
    get_PointX(int i): return the i-th x coordinate of the triangulation
    get_PointY(int i): return the i-th y coordinate of the triangulation

TODO:
    edge_iterator;
    face_iterator;
    vertex_iterator;
    copy constructor;
    constructor indepent of triangle
*/

#ifndef TRIANGULATION_HPP
#define TRIANGULATION_HPP

#include <array>
#include <vector>
#include <iostream>
#include <fstream>
#include <cmath>
#include <sstream>
#include <unordered_map>
#include <map>
#include <set>
#include <chrono>
#include <iomanip>
#include <iterator>
#include <filesystem>
#include <list>

struct vertex{
    double x;
    double y;
    bool is_border = false; // if the vertex is on the boundary
    int incident_halfedge; // halfedge incident to the vertex, vertex is the origin of the halfedge
};



struct halfEdge {
    int origin; //tail of edge
    //int target; //head of edge
    int twin; //opposite halfedge
    int next; //next halfedge of the same face
    int prev; //previous halfedge of the same face
    int face; //face the halfedge belongs to
    int is_border; //1 if the halfedge is on the boundary, 0 otherwise
};

// Esta fue la unica funci√≥n ql funciono, porque las weas nativas de c++ funcionan mal
//https://stackoverflow.com/a/22395635
// Returns false if the string contains any non-whitespace characters
// Returns false if the string contains any non-ASCII characters
bool isWhitespace(std::string s){
    for(int index = 0; index < s.length(); index++)
        if(!std::isspace(s[index]))
            return false;
    return true;
}

class Triangulation 
{

private:

    typedef std::array<int,3> _triangle; 
    typedef std::pair<int,int> _edge;
    typedef std::pair<double, double> point;

    friend class Region;
    friend class Criterion;
    friend class Refiner;
    friend class BaseQueue;
    friend class Points;

    //Statically data
    int n_halfedges = 0; //number of halfedges
    int n_faces = 0; //number of faces
    int n_vertices = 0; //number of vertices
    int n_border_edges = 0; //number of border edges
    double t_triangulation_generation = 0; //time to generate the triangulation

    public:
    std::vector<vertex> Vertices;
    std::vector<halfEdge> HalfEdges; //list of edges
    //std::vector<char> triangle_flags; //list of edges that generate a unique triangle,  
    
    public:
    std::set<int> triangle_list; //list of edges that generate a unique triangle,

    //Read node file in .node format and nodes in point vector
    void read_nodes_from_file(std::string name){
        std::string line;
        std::ifstream nodefile(name);
        double a1, a2, a3, a4;
        
        //std::cout<<"Node file"<<std::endl;
        if (nodefile.is_open())
        {
            nodefile >> n_vertices;
            //std::cout<<pnumber<<std::endl;
            Vertices.reserve(n_vertices);
            std::getline(nodefile, line); //skip the first line
            while (std::getline(nodefile, line))
            {
                std::istringstream(line) >> a1 >> a2 >> a3 >> a4;
                vertex ve;
                ve.x =  a2;
                ve.y =  a3;
                ve.is_border = (a4 == 1) ? true : false;
                Vertices.push_back(ve);
            }  
        }
        else 
            std::cout << "Unable to open node file"; 
        nodefile.close();
    }

    //Read triangle file in .ele format and stores it in faces vector
    std::vector<int> read_triangles_from_file(std::string name){
        std::vector<int> faces;
        std::string line;
        std::ifstream elefile(name);
        int a1, a2, a3, a4;
        
        //std::cout<<"Node file"<<std::endl;
        if (elefile.is_open())
        {
            elefile >> n_faces;
            //std::cout<<pnumber<<std::endl;
            faces.reserve(3*n_faces);
            std::getline(elefile, line); //skip the first line
            while (std::getline(elefile, line))
            {
                std::istringstream(line) >> a1 >> a2 >> a3 >> a4;
                faces.push_back(a2);
                faces.push_back(a3);
                faces.push_back(a4);
                //std::cout<<"Vertex "<<a1<<" "<<v.x<<" "<<v.y<<" "<<v.is_border<<std::endl;
            }
        }
        else 
            std::cout << "Unable to open node file"; 
        elefile.close();

        return faces;
    }

    //Read node file in .node format and nodes in point vector
    std::vector<int>  read_neigh_from_file(std::string name){
        std::vector<int> neighs;
        std::string line;
        std::ifstream neighfile(name);
        int a1, a2, a3, a4;
        
        //std::cout<<"Node file"<<std::endl;
        if (neighfile.is_open())
        {
            neighfile >> n_faces;
            //std::cout<<pnumber<<std::endl;
            neighs.reserve(3*n_faces);
            std::getline(neighfile, line); //skip the first line
            while (std::getline(neighfile, line))
            {
                if(line[0] == '#'){
                    std::cout<<line<<std::endl;
                    continue;
                }
                std::istringstream(line) >> a1 >> a2 >> a3 >> a4;
                
                neighs.push_back(a2);
                neighs.push_back(a3);
                neighs.push_back(a4);

                // count all number minior than 0 as border edges
                if(a2 < 0){
                    n_border_edges++;
                    //std::cout<<"Border edge 0 "<<a1<<" "<<a2<<" "<<a3<<" "<<a4<<std::endl;
                }
                if(a3 < 0){
                    n_border_edges++;
                    //std::cout<<"Border edge 1 "<<a1<<" "<<a2<<" "<<a3<<" "<<a4<<std::endl;
                }
                if(a4 < 0){
                    n_border_edges++;
                    //std::cout<<"Border edge 2 "<<a1<<" "<<a2<<" "<<a3<<" "<<a4<<std::endl;
                }
            }
        }
        else 
            std::cout << "Unable to open node file"; 
        neighfile.close();
        return neighs;
    }


    void construct_interior_halfEdges_from_faces(std::vector<int> &faces){
        //std::cout << "0. aca "<< std::endl;	
        auto hash_for_pair = [n = 3*this->n_faces](const std::pair<int, int>& p) {
            return std::hash<int>{}(p.first)*n + std::hash<int>{}(p.second);
        };
        std::unordered_map<_edge, int, decltype(hash_for_pair)> map_edges(3*this->n_faces, hash_for_pair); //set of edges to calculate the boundary and twin edges
        for(std::size_t i = 0; i < n_faces; i++){
            for(std::size_t j = 0; j < 3; j++){
                halfEdge he;
                int v_origin = faces.at(3*i+j);
                int v_target = faces.at(3*i+(j+1)%3);
                he.origin = v_origin;
                he.next = i*3+(j+1)%3;
                he.prev = i*3+(j+2)%3;
                he.is_border = false;
                he.twin = -1;
                he.face = 3*i;
                Vertices.at(v_origin).incident_halfedge = i*3+j;
                map_edges[std::make_pair(v_origin, v_target)] = i*3+j;
                HalfEdges.push_back(he);
            }
        }
        
        //Calculate twin halfedge and boundary halfedges from set_edges
        std::unordered_map<_edge,int, decltype(hash_for_pair)>::iterator it;
        for(std::size_t i = 0; i < HalfEdges.size(); i++){
            //if halfedge has no twin
            if(HalfEdges.at(i).twin == -1){
                int tgt = origin(next(i));
                int org = origin(i);
                _edge twin = std::make_pair(tgt, org);
                it=map_edges.find(twin);
                //if twin is found
                if(it!=map_edges.end()){
                    int index_twin = it->second;
                    HalfEdges.at(i).twin = index_twin;
                    HalfEdges.at(index_twin).twin = i;
                }else{ //if twin is not found and halfedge is on the boundary
                    HalfEdges.at(i).is_border = true;
                    Vertices.at(org).is_border = true;
                    Vertices.at(tgt).is_border = true;
                }
            }
        }
        //std::cout << "3. aca "<< std::endl;	
    }

    //Generate interior halfedges using faces and neigh vectors
    //also associate each vertex with an incident halfedge
    void construct_interior_halfEdges_from_faces_and_neighs(std::vector<int> &faces, std::vector<int> &neighs){
        int neigh, origin, target;
        for(std::size_t i = 0; i < n_faces; i++){
            for(std::size_t j = 0; j < 3; j++){
                halfEdge he;
                neigh = neighs.at(3*i + ((j+2)%3));
                origin = faces[3*i+j];
                target = faces[3*i+((j+1)%3)];

                he.origin = origin;
               // he.target = target;
                he.next = 3*i + ((j+1)%3);
                he.prev = 3*i + ((j+2)%3);
                he.face = 3*i;
                he.is_border = (neigh == -1);
                if(neigh != -1){
                    for (std::size_t j = 0; j < 3; j++){
                        if(faces.at(3*neigh + j) == target && faces.at(3*neigh + (j + 1)%3) == origin){
                            he.twin = 3*neigh + j;
                            break;
                        }
                    }
                }else
                    he.twin = -1;
                HalfEdges.push_back(he);
                Vertices[he.origin].incident_halfedge = i*3 + j;
            }
        }
    }

    
    //Generate exterior halfedges
    //This takes  n + k time where n is the number of vertices and k is the number of border edges
    void construct_exterior_halfEdges(){

        //search interior edges labed as border, generates exterior edges
        //with the origin and target inverted and add at the of HalfEdges vector
        //std::cout<<"Size vector: "<<HalfEdges.size()<<std::endl;
        this->n_halfedges = HalfEdges.size();
        for(std::size_t i = 0; i < this->n_halfedges; i++){
            if(HalfEdges.at(i).is_border){
                halfEdge he_aux;
                //he_aux.face = -1;
                he_aux.twin = i;
                he_aux.origin = origin(next(i));
                //he_aux.target = HalfEdges.at(i).origin;
                he_aux.is_border = true;
                HalfEdges.at(i).is_border = false;
                
                HalfEdges.push_back(he_aux);
                HalfEdges.at(i).twin = HalfEdges.size() - 1 ;
            }    
        }
        //traverse the exterior edges and search their next prev halfedge
        int nxtCCW, prvCCW;
        for(std::size_t i = n_halfedges; i < HalfEdges.size(); i++){
            if(HalfEdges.at(i).is_border){
                nxtCCW = CCW_edge_to_vertex(HalfEdges.at(i).twin);
                while (HalfEdges.at(nxtCCW).is_border != true)
                    nxtCCW = this->CCW_edge_to_vertex(nxtCCW);
                HalfEdges.at(i).next = nxtCCW;

                prvCCW = this->next(twin(i));
                while (HalfEdges.at(HalfEdges.at(prvCCW).twin).is_border != true)
                    prvCCW = this->CW_edge_to_vertex(prvCCW);
                HalfEdges.at(i).prev = HalfEdges.at(prvCCW).twin;
            }
        }
        this->n_halfedges = HalfEdges.size();
    }


    //Read the mesh from a file in OFF format
    std::vector<int> read_OFFfile(std::string name){
        //Read the OFF file
        std::vector<int> faces;
		std::string line;
		std::ifstream offfile(name);
		double a1, a2, a3;
		std::string tmp;
		if (offfile.is_open())
		{
            //Check first line is a OFF file
			while (std::getline(offfile, line)){ //add check boundary vertices flag
                std::istringstream(line) >> tmp;
                //std::cout<<"tmp: "<<tmp<<std::endl;
				if (tmp[0] != '#' && !isWhitespace(line))
				{
					if(tmp[0] == 'O' && tmp[1] == 'F' && tmp[2] == 'F') //Check if the format is OFF
                        break;
                    else{
                        std::cout<<"The file is not an OFF file"<<std::endl;
                        exit(0);
                    }
				}
			}

            //Read the number of vertices and faces
            while (std::getline(offfile, line)){ //add check boundary vertices flag
                std::istringstream(line) >> tmp;
               // std::cout<<"tmp: "<<tmp<<std::endl;
				if (tmp[0] != '#' && !isWhitespace(line))
                { 
                            std::istringstream(line) >> this->n_vertices >> this->n_faces;
                            this->Vertices.reserve(this->n_vertices);
                            faces.reserve(3*this->n_faces);
                            break;
                            
                }
			}

            //Read vertices
            int index = 0;
			while (index < n_vertices && std::getline(offfile, line) )
			{
				std::istringstream(line) >> tmp;
                // std::cout<<"tmp: "<<tmp<<std::endl;
				if (tmp[0] != '#' && !isWhitespace(line))
				{
					std::istringstream(line) >> a1 >> a2 >> a3;
					vertex ve;
                    ve.x =  a1;
                    ve.y =  a2;
                    this->Vertices.push_back(ve);
                    index++;
				}
			}
            //Read faces
            
            int lenght, t1, t2, t3;
            index = 0;
			while (index < n_faces && std::getline(offfile, line) )
			{
				std::istringstream(line) >> tmp;
                // std::cout<<"tmp: "<<tmp<<std::endl;
				if (tmp[0] != '#' && !isWhitespace(line))
				{
                    std::istringstream(line) >> lenght >> t1 >> t2 >> t3;
                    faces.push_back(t1);
                    faces.push_back(t2);
                    faces.push_back(t3);
          //          std::cout<<"face "<<index<<": "<<t1<<" "<<t2<<" "<<t3<<std::endl;
                    index++;
				}
			}

		}
		else 
				std::cout << "Unable to open node file"; 
		offfile.close();
        return faces;
    }


public:

    //default constructor
    Triangulation() {}

    //Constructor from file
    Triangulation(std::string node_file, std::string ele_file, std::string neigh_file) {
        std::vector<int> faces;
        std::vector<int> neighs;
        std::cout<<"Reading node file"<<std::endl;
        read_nodes_from_file(node_file);
        //fusionar estos dos m√©todos
        std::cout<<"Reading ele file"<<std::endl;
        faces = read_triangles_from_file(ele_file);
        std::cout<<"Reading neigh file"<<std::endl;
        neighs = read_neigh_from_file(neigh_file);

        //calculation of the time to build the data structure
        auto t_start = std::chrono::high_resolution_clock::now();
        HalfEdges.reserve(3*n_vertices - 3 - n_border_edges);
        //std::cout<<"Constructing interior halfedges"<<std::endl;
        construct_interior_halfEdges_from_faces_and_neighs(faces, neighs);
        //std::cout<<"Constructing exterior halfedges"<<std::endl;
        construct_exterior_halfEdges();

        getTriangles();
        
        //std::cout<<"Constructing triangles"<<std::endl;
        auto t_end = std::chrono::high_resolution_clock::now();
        t_triangulation_generation = std::chrono::duration<double, std::milli>(t_end-t_start).count();
    }

    Triangulation(std::string OFF_file){
        std::cout<<"Reading OFF file "<<OFF_file<<std::endl;
        std::vector<int> faces = read_OFFfile(OFF_file);

        std::cout<<"Constructing interior halfedges"<<std::endl;
        auto t_start = std::chrono::high_resolution_clock::now();
        HalfEdges.reserve(3*n_vertices);
        construct_interior_halfEdges_from_faces(faces);
        std::cout<<"Constructing exterior halfedges"<<std::endl;
        construct_exterior_halfEdges();

        getTriangles();

        auto t_end = std::chrono::high_resolution_clock::now();
        t_triangulation_generation = std::chrono::duration<double, std::milli>(t_end-t_start).count();
    }

    // Copy constructor
    Triangulation(const Triangulation &t) {
        this->n_vertices = t.n_vertices;
        this->n_faces = t.n_faces;
        this->n_halfedges = t.n_halfedges;
        this->Vertices = t.Vertices;
        this->HalfEdges = t.HalfEdges;
        this-> t_triangulation_generation = t.t_triangulation_generation;
        this->triangle_list = t.triangle_list;
    }

    Triangulation(int size){
        int n = size;
        int sqrt_n = (int)sqrt(size);

        n_vertices = size;
        std::vector<int> faces;

        this->Vertices.reserve(this->n_vertices);
        faces.reserve(2*(n-sqrt_n));

        std::cout<<"Generating points  "<<std::endl;
        for (int i = 0; i < sqrt_n; i++)
            for (int j = 0; j < sqrt_n; j++)
            {
                vertex ve;
                ve.x =  (float)i;
                ve.y =  (float)j;
                this->Vertices.push_back(ve);
            }
        
        std::cout<<"Generating triangles "<<std::endl;
        for (int i = 0; i < n-sqrt_n; i++)
        {
            if (i % sqrt_n != sqrt_n-1){
                faces.push_back(i);
                faces.push_back(i+1);
                faces.push_back(i+sqrt_n+1);

                faces.push_back(i);
                faces.push_back(i+sqrt_n+1);
                faces.push_back(i+sqrt_n);
            }
        }

        n_faces = faces.size()/3;
        std::cout<<"estimao "<< n_faces<<" final "<<n_faces<<std::endl;

        std::cout<<"Constructing halfedges..."<<std::endl;
        auto t_start = std::chrono::high_resolution_clock::now();      
        HalfEdges.reserve(3*n_vertices);
        std::cout<<"Constructing interior halfedges"<<std::endl;
        construct_interior_halfEdges_from_faces(faces);
        std::cout<<"Constructing exterior halfedges"<<std::endl;
        construct_exterior_halfEdges();

        getTriangles();

        auto t_end = std::chrono::high_resolution_clock::now();
        t_triangulation_generation = std::chrono::duration<double, std::milli>(t_end-t_start).count();
        std::cout<<"Triangulation generation time: "<<t_triangulation_generation<<std::endl;
    }


    // destructor
    ~Triangulation() {
        Vertices.clear();
        HalfEdges.clear();
        triangle_list.clear();
    }

    double get_triangulation_generation_time() {
        return t_triangulation_generation;
    }

    long long get_size_vertex_struct() {
        return sizeof(decltype(Vertices.back())) * Vertices.capacity();
    }

    long long get_size_vertex_half_edge() {
        return sizeof(decltype(HalfEdges.back())) * HalfEdges.capacity();
    }

    // Calculates the distante of edge e
    double distance(int e){
        double x1 = Vertices.at(origin(e)).x;
        double y1 = Vertices.at(origin(e)).y;
        double x2 = Vertices.at(target(e)).x;
        double y2 = Vertices.at(target(e)).y;
        return pow(x1-x2,2) + pow(y1-y2,2); //no sqrt for performance
    }

    // Calculates the distance between to points (structure <point>)
    double distance(point p1, point p2) {
        double x1 = p1.first;
        double y1 = p1.second;
        double x2 = p2.first;
        double y2 = p2.second;
        return sqrt(pow(x1-x2,2) + pow(y1-y2,2));
    }

    //int face_index(int i){
    //    return HalfEdges.at(i).face;
    //}

    //Return triangle of the face incident to edge e
    //Input: e is the edge
    //output: array with the vertices of the triangle
    _triangle incident_face(int e)
    {   
        _triangle face;  
        int nxt = e;
        int init_vertex = origin(nxt);
        int curr_vertex = -1;
        int i = 0;
        while ( curr_vertex != init_vertex )
        {
            nxt = next(nxt);            
            curr_vertex = origin(nxt);
            face.at(i) = curr_vertex;
            i++;
        }
        return face;
    }


    //Print off file of the triangulation
    void print_OFF(std::string filename){
        std::ofstream out(filename);

      //  out<<"{ appearance  {+edge +face linewidth 2} LIST\n";
        out<<"OFF"<<std::endl;
        //num_vertices num_polygons 0
        out<<std::setprecision(15)<<n_vertices<<" "<<n_faces<<" 0"<<std::endl;
        //print nodes
        for(int i = 0; i < n_vertices; i++)
            out<<get_PointX(i)<<" "<<get_PointY(i)<<" 0"<<std::endl; 
        //print triangles
        for(int i: triangle_list){
            out<<3;
            int currEdge = i;
            for (int j = 0; j < 3; j++) {
                out<<" "<<origin(currEdge);
                currEdge = next(currEdge);
            }
            out<<std::endl;
        }
        out.close();
    }


    //function to check if a triangle is counterclockwise
    //Input: array with the vertices of the triangle
    //Output: true if the triangle is counterclockwise, false otherwise
    bool is_counterclockwise(_triangle tr)
    {
        int v0 = tr.at(0);
        int v1 = tr.at(1);
        int v2 = tr.at(2);
        vertex ve0 = Vertices.at(v0);
        vertex ve1 = Vertices.at(v1);
        vertex ve2 = Vertices.at(v2);
        double area = 0.0;
            //int val = (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y);
        area = (Vertices.at(v2).x - Vertices.at(v1).x) * (Vertices.at(v1).y - Vertices.at(v0).y) - (Vertices.at(v2).y - Vertices.at(v1).y) * (Vertices.at(v1).x - Vertices.at(v0).x);
        if(area < 0)
            return true;
        return false;
    }


    //Given a edge with vertex origin v, return the next coutnerclockwise edge of v with v as origin
    //Input: e is the edge, ccw indicates if the structure is oriented in counterclockwise or not
    //Output: the next counterclockwise edge of v
    int CCW_edge_to_vertex(int e, bool ccw=true)
    {
        if (ccw) {
            int twn, nxt;
            nxt = HalfEdges.at(e).prev;
            twn = HalfEdges.at(nxt).twin;
            return twn;
        }
        return CW_edge_to_vertex(e, true);
    }    

    //Given a edge with vertex origin v, return the prev clockwise edge of v with v as origin
    //Input: e is the edge, ccw indicates if the structure is oriented in counterclockwise or not
    //Output: the prev clockwise edge of v
    int CW_edge_to_vertex(int e, bool ccw=true)
    {
        if (ccw) {
            int twn, nxt;
            twn = HalfEdges.at(e).twin;
            nxt = HalfEdges.at(twn).next;
            return nxt;
        }
        return CCW_edge_to_vertex(e, true);
    }    

    //return number of faces
    int faces(){
        return n_faces;
    }

    int get_number_triangles() {
        return triangle_list.size();
    }

    int get_number_edges() {
        return HalfEdges.size()/2;
    }

    //Return number of halfedges
    int halfEdges(){
        return n_halfedges;
    }

    //Return number of vertices
    int vertices(){
        return n_vertices;
    }

    int get_number_vertices() {
        return Vertices.size();
    }

    // Calculate some metrics about the triangulation, like min and max angles or min and max area.
    std::vector<double> get_metrics() {
        int some_edge = *(triangle_list.begin());
        double max_area = get_area(some_edge);
        double min_area = max_area;

        double a1 = angle(some_edge, twin(prev(some_edge)));
        some_edge = next(some_edge);
        double a2 = angle(some_edge, twin(prev(some_edge)));
        some_edge = next(some_edge);
        double a3 = angle(some_edge, twin(prev(some_edge)));

        double max_angle = std::max(a1, std::max(a2, a3));
        double min_angle = std::min(a1, std::min(a2, a3));
        double area;
        double curr_angle;
        double sum_area = 0;

        for(auto triangle: triangle_list) {
            area = get_area(triangle);
            sum_area += area;
            if (area > max_area) {
                max_area = area;
            }
            else if (area < min_area) {
                min_area = area;
            }

            for (int i = 0; i<3; i++) {
                curr_angle = angle(triangle, twin(prev(triangle)));
                if (curr_angle > max_angle) {
                    max_angle = curr_angle;
                }
                else if (curr_angle < min_angle) {
                    min_angle = curr_angle;
                }
                triangle = next(triangle);
            }
        }
        return {max_area, min_area, sum_area/triangle_list.size(), max_angle, min_angle};
    }


    //list of triangles where true if the halfege generate a unique face, false if the face is generated by another halfedge
    //Replace by a triangle iterator
    std::set<int> getTriangles(){
        if (triangle_list.size() == 0) {
            for(std::size_t i = 0; i < n_faces; i++)
                triangle_list.insert(3*i);
        }
        return triangle_list;
    }

    double get_PointX(int i){
        return Vertices.at(i).x;
    }

    double get_PointY(int i){
        return Vertices.at(i).y;
    }

    //Calculates the next edge of the face incident to edge e
    //Input: e is the edge
    //Output: the next edge of the face incident to e
    int next(int e){
        return HalfEdges.at(e).next;
    }

    //Calculates the tail vertex of the edge e
    //Input: e is the edge
    //Output: the tail vertex v of the edge e
    int origin(int e){
        return HalfEdges.at(e).origin;
    }


    //Calculates the head vertex of the edge e
    //Input: e is the edge
    //Output: the head vertex v of the edge e
    int target(int e){
        //return HalfEdges.at(e).target;
        return this->origin(HalfEdges.at(e).twin);
    }

    //Return the twin edge of the edge e
    //Input: e is the edge
    //Output: the twin edge of e
    int twin(int e){
        return HalfEdges.at(e).twin;
    }

    //Return the twin edge of the edge e
    //Input: e is the edge
    //Output: the twin edge of e
    int prev(int e)
    {
        return HalfEdges.at(e).prev;
    }

    int face(int e) {
        return HalfEdges.at(e).face;
    }

    //return a edge associate to the node v
    //Input: v is the node
    //Output: the edge associate to the node v
    int edge_of_vertex(int v)
    {
        return Vertices.at(v).incident_halfedge;
    }

    //Input: edge e
    //Output: true if is the face of e is border face
    //        false otherwise
    bool is_border_edge(int e)
    {
        return HalfEdges.at(e).is_border;
    }

    // Input: edge e of compressTriangulation
    // Output: true if the edge is an interior face a
    //         false otherwise
    bool is_interior_face(int e)
    {
       return !this->is_border_edge(e);
    }

    //Input:vertex v
    //Output: the edge incident to v, wiht v as origin
    bool is_border_vertex(int v)
    {
        return Vertices.at(v).is_border;
    }

    //Halfedge update operations
    void set_next(int e, int nxt)
    {
        HalfEdges.at(e).next = nxt;
    }

    void set_prev(int e, int prv)
    {
        HalfEdges.at(e).prev = prv;
    }

    //void set_face(int e, int f)
    //{
    //    HalfEdges.at(e).face = f;
    //}

    int degree(int v)
    {
        int e_curr = edge_of_vertex(v);
        int e_next = CCW_edge_to_vertex(e_curr);
        int adv = 1;
        while (e_next != e_curr)
        {
            e_next = CCW_edge_to_vertex(e_next);
            adv++;
        }
        return adv;
    }

    int incident_halfedge(int f)
    {
        // return 3*f;
        // Ahora que hay inserci√≥n de puntos, el arreglo no cumple con esto.
        return *(triangle_list.find(f));
    }


    int label_max_edge(const int e)
    {
        //Calculates the size of each edge of a triangle 
        double dist0 = distance(e);
        double dist1 = distance(next(e));
        double dist2 = distance(prev(e));
        //Find the longest edge of the triangle
        if(std::max({dist0, dist1, dist2}) == dist0)
            return e;
        else if(std::max({dist0, dist1, dist2}) == dist1)
            return next(e);
        else
            return prev(e);
    }


    // Checks if every edge is legal, returning if the triangulation is Delaunay
    bool is_delaunay_triangulation() {
        int i = 0;
        int number_edges = HalfEdges.size()/2;
        for (std::size_t e=0; e<HalfEdges.size(); e++) {
            if (i == number_edges) {
                return true;
            }
            if (twin(e) > e) {
                i++;
                // Margin for the angle to be considered illegal
                if (isIllegal(e, 0.00000000001)) {
                    return false;
                }
            }
        }
        return true;
    }

    // Computes the longest-edge propagation path of the triangle that has e as an edge
    std::vector<int> lepp(int e) {
        std::vector<int> triangles;

        int max_edge;
        int current_edge = e;

        while (true) {
            max_edge = label_max_edge(current_edge);
            triangles.push_back(max_edge);

            bool isBorder = is_border_edge(max_edge) || is_border_edge(twin(max_edge));
            int twinEdge = twin(max_edge);
            int twinMax = label_max_edge(twinEdge);
            bool isTerminalEdge = (twinMax == twin(max_edge));

            if (isBorder || isTerminalEdge) {
                break;
            }
            else {
                current_edge = twin(max_edge);
            }
        }

        return triangles;
    }

    // Checks if a given edge is illegal in the triangulation.
    bool isIllegal(int e) {
        if (!is_border_edge(e) && !is_border_edge(twin(e))) {
            // If the opposites angles of a quadrilateral formed by two triangles is bigger than 180¬∞, the edge is illegal
            // (not locally Delaunay)
            double angle1 = angle(prev(e), twin(next(e)));
            double angle2 = angle(prev(twin(e)), twin(next(twin(e))));
            return angle1 + angle2 > M_PI;
        }
        return false;
    }

    // Checks if a given edge is illegal in the triangulation, with epsilon as margin of error.
    bool isIllegal(int e, double epsilon) {
        if (!is_border_edge(e) && !is_border_edge(twin(e))) {
            // If the opposites angles of a quadrilateral formed by two triangles is bigger than 180¬∞, the edge is illegal
            // (not locally Delaunay)
            double angle1 = angle(prev(e), twin(next(e)));
            double angle2 = angle(prev(twin(e)), twin(next(twin(e))));
            return angle1 + angle2 > M_PI + epsilon;
        }
        return false;
    }

    // Flips the edge e
    std::vector<std::pair<int, int>> edgeFlip(int e) {
        
        std::vector<std::pair<int, int>> trianglesModified;

        Vertices.at(origin(e)).incident_halfedge = next(twin(e));
        Vertices.at(target(e)).incident_halfedge = next(e);

        halfEdge e1 = HalfEdges.at(e);
        halfEdge e2 = HalfEdges.at(twin(e));

        e1.next = next(next(e));
        e1.prev = next(twin(e));
        e1.origin = target(next(twin(e)));

        e2.next = prev(twin(e));
        e2.prev = next(e);
        e2.origin = target(next(e));

        HalfEdges.at(prev(e)).next = next(twin(e));
        HalfEdges.at(prev(e)).prev = e;

        HalfEdges.at(next(e)).next = twin(e);
        HalfEdges.at(next(e)).prev = prev(twin(e));

        // Special case where the face is defined by an edge that change to the other triangle by the edge-flip
        if (e2.face == next(twin(e))) {
            HalfEdges.at(prev(twin(e))).face = twin(e);
            HalfEdges.at(next(e)).face = twin(e);
            std::set<int>::iterator position;
            position = triangle_list.find(e2.face);
            if (position == triangle_list.end()) {
                std::cout << "The face was not found (This should never happen)." << std::endl;
            }
            else {
                triangle_list.erase(position);
                triangle_list.insert(twin(e));
            }
            trianglesModified.push_back({e2.face, twin(e)});
            e2.face = twin(e);
            //std::cout << cuantas_veces_pasa << std::endl;
        }
        else {
            trianglesModified.push_back({e2.face, e2.face});
            HalfEdges.at(next(e)).face = e2.face;
        }

        HalfEdges.at(next(twin(e))).next = e;
        HalfEdges.at(next(twin(e))).prev = prev(e);

        // Special case where the face is defined by an edge that change to the other triangle by the edge-flip (for
        // the other triangle)
        if (e1.face == next(e)) {
            HalfEdges.at(prev(e)).face = e;
            HalfEdges.at(next(twin(e))).face = e;
            std::set<int>::iterator position;
            position = triangle_list.find(e1.face);
            if (position == triangle_list.end()) {
                std::cout << "The face was not found (why?)." << std::endl;
            }
            else {
                triangle_list.erase(position);
                triangle_list.insert(e);
            }
            trianglesModified.push_back({e1.face, e});
            e1.face = e;
            //std::cout << cuantas_veces_pasa << std::endl;
        }
        else {
            trianglesModified.push_back({e1.face, e1.face});
            HalfEdges.at(next(twin(e))).face = e1.face;
        }

        HalfEdges.at(prev(twin(e))).next = next(e);
        HalfEdges.at(prev(twin(e))).prev = twin(e);

        HalfEdges.at(twin(e)) = e2;
        HalfEdges.at(e) = e1;

        return trianglesModified;
    }

    // Performs the edge-flipping algorithm to convert a random triangulation to a Delaunay one
    void repairDelaunay() {
        // This is used as a stack in the algorithm
        std::vector<int> edges_to_check;
        edges_to_check.reserve(HalfEdges.size()/2);
        for (std::size_t e=0; e<HalfEdges.size(); e++) {
            if (e < twin(e) && !is_border_edge(e) && !is_border_edge(twin(e))) {
                edges_to_check.push_back(e);
            }
        }
        while (edges_to_check.size() > 0) {
            int e = edges_to_check.back();
            edges_to_check.pop_back();
            if (isIllegal(e)) {
                edgeFlip(e);
                if (!is_border_edge(next(e)) && !is_border_edge(twin(next(e)))) {
                    edges_to_check.push_back(next(e));
                }
                if (!is_border_edge(prev(e)) && !is_border_edge(twin(prev(e)))) {
                    edges_to_check.push_back(prev(e));
                }
                if (!is_border_edge(next(twin(e))) && !is_border_edge(twin(next(twin(e))))) {
                    edges_to_check.push_back(next(twin(e)));
                }
                if (!is_border_edge(prev(twin(e))) && !is_border_edge(twin(prev(twin(e))))) {
                    edges_to_check.push_back(prev(twin(e)));
                }
            }
        }
    }

    // Computes the centroid of the quadrilateral that has e as diagonal.
    point get_centroid(int e) {
        point a = {get_PointX(origin(e)), get_PointY(origin(e))};
        point b = {get_PointX(target(e)), get_PointY(target(e))};
        point c = {get_PointX(target(next(e))), get_PointY(target(next(e)))};
        point d = {get_PointX(target(next(twin(e)))), get_PointY(target(next(twin(e))))};

        point c1 = {(a.first + b.first + c.first) / 3, (a.second + b.second + c.second) / 3};
        point c2 = {(a.first + b.first + d.first) / 3, (a.second + b.second + d.second) / 3};
        point c3 = {(a.first + c.first + d.first) / 3, (a.second + c.second + d.second) / 3};
        point c4 = {(b.first + c.first + d.first) / 3, (b.second + c.second + d.second) / 3};

        if (intersects(c1, c2, c3, c4).first) {
            return get_intersection(c1, c2, c3, c4);
        }
        else {
            throw std::runtime_error("The centroid for quadrilateral with terminal edge " + std::to_string(e) + " could not be calculated (the lines do not intersect).");
        }
    }

    // Determine if two segments intersects
    // Returns a pair, with the first value being wether the segments intersects, and the second value indicating if the first point lies in the segment
    // formed by c3 and c4
    std::pair<bool, bool> intersects(point c1, point c2, point c3, point c4) {
        int orientation123 = orientation(c1, c2, c3);
        int orientation124 = orientation(c1, c2, c4);
        if (orientation123 == orientation124) {
            // All points are collinear
            if (orientation123 == 0) {
                bool c1_in_c3c4 = on_segment_collinear(c3, c4, c1);
                return {on_segment_collinear(c1, c2, c3) || on_segment_collinear(c1, c2, c4) || on_segment_collinear(c3, c4, c2) || c1_in_c3c4, c1_in_c3c4};
            }
            return {false, false};
        }
        
        int orientation341 = orientation(c3, c4, c1);
        int orientation342 = orientation(c3, c4, c2);

        return {orientation341 != orientation342, orientation341==0};
    }

    // Determines if the point c3 lies on the segment formed by c1 and c2
    bool on_segment_collinear(point c1, point c2, point c3) {
        if (c1.first != c2.first) {
            double max_x = std::max(c1.first, c2.first);
            double min_x = std::min(c1.first, c2.first);
            return c3.first <= max_x & c3.first >= min_x;
        }
        double max_y = std::max(c1.second, c2.second);
        double min_y = std::min(c1.second, c2.second);
        return c3.second <= max_y && c3.second >= min_y;
    }

    // Returns the point of intersection of the segments c1c2 and c3c4. (The segments have to intersect, otherwise
    // the result is undefined).
    point get_intersection(point c1, point c2, point c3, point c4) {
        double f1 = (c1.first*c2.second-c1.second*c2.first);
        double f2 = (c3.first*c4.second-c3.second*c4.first);
        double d = (c1.first-c2.first)*(c3.second-c4.second)-(c1.second-c2.second)*(c3.first-c4.first);

        double x = (f1*(c3.first-c4.first) - (c1.first - c2.first)*f2)/d;
        double y = (f1*(c3.second-c4.second) - (c1.second - c2.second)*f2)/d;

        return {x, y};
    }

    /*
    double get_area(int triangle) {

        double x1 = Vertices.at(origin(triangle)).x;
        double y1 = Vertices.at(origin(triangle)).y;

        double x2 = Vertices.at(target(triangle)).x;
        double y2 = Vertices.at(target(triangle)).y;

        double x3 = Vertices.at(target(next(triangle))).x;
        double y3 = Vertices.at(target(next(triangle))).y;

        double a1 = x1 * (y2 - y3);
        double a2 = x2 * (y3 - y1);
        double a3 = x3 * (y1 - y2);

        return std::abs((a1 + a2 + a3) / 2);
    }
    */


    // Returns the area of the triangle
    double get_area(int triangle) {

        double x1 = Vertices.at(origin(triangle)).x;
        double y1 = Vertices.at(origin(triangle)).y;

        double x2 = Vertices.at(target(triangle)).x;
        double y2 = Vertices.at(target(triangle)).y;

        double x3 = Vertices.at(target(next(triangle))).x;
        double y3 = Vertices.at(target(next(triangle))).y;

        return std::abs(((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)) / 2);
    }

    // Returns the orientation of the three points given. 
    // output: 1: The points are in counterclockwise order
    //         0: The points are collinear
    //         -1: The points are in clockwise order
    int orientation(point p0, point p1, point p2)
    {
        double area = 0.0;
            //int val = (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y);
        area = (p2.first - p1.first) * (p1.second - p0.second) - (p2.second - p1.second) * (p1.first - p0.first);
        if(area < 0)
            return 1;
        else if (area > 0) {
            return -1;
        }
        return 0;
    }

    // Returns the angle (radians) formed by the edges e1 and e2
    double angle(int e1, int e2) {
        
        int v1 = target(e1);
        int v2 = origin(e2);
        int v3 = target(e2);

        double v1x = get_PointX(v1) - get_PointX(v2);
        double v1y = get_PointY(v1) - get_PointY(v2);

        double v3x = get_PointX(v3) - get_PointX(v2);
        double v3y = get_PointY(v3) - get_PointY(v2);

        return acos((v1x*v3x + v1y*v3y)/(sqrt((pow(v1x,2) + pow(v1y,2)))*sqrt((pow(v3x,2) + pow(v3y,2)))));
    }
};

#endif